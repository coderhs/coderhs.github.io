<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rails on Harisankar P S | Ruby on Rails Developer</title>
    <link>https://hsps.in/tags/rails/</link>
    <description>Recent content in Rails on Harisankar P S | Ruby on Rails Developer</description>
    <generator>Hugo</generator>
    <language>en</language>
    <copyright>Harisankar P S</copyright>
    <lastBuildDate>Thu, 10 Oct 2024 00:05:58 -0700</lastBuildDate>
    <atom:link href="https://hsps.in/tags/rails/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Running Rails Migrations in AWS ECS Using AWS CLI</title>
      <link>https://hsps.in/post/run-rails-db-migrate-on-ecs-task-aws/</link>
      <pubDate>Thu, 10 Oct 2024 00:05:58 -0700</pubDate>
      <guid>https://hsps.in/post/run-rails-db-migrate-on-ecs-task-aws/</guid>
      <description>&lt;p&gt;AWS ECS (Elastic Container Service) is a powerful Amazon Web Service that allows you to deploy Docker containers on various infrastructure options, including EC2 instances, Fargate (serverless containers), or even self-hosted servers. Being deeply integrated with AWS, ECS offers a cost-effective and seamless solution for managing containers in the Amazon ecosystem.&lt;/p&gt;&#xA;&lt;p&gt;This guide assumes you are familiar with ECS and already have a task definition set up for your Rails application. Additionally, it assumes you know how to find your subnet ID and security group ID, as these will be required when running containers in your specific environment.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Change Action Mailer Settings From Rails Console</title>
      <link>https://hsps.in/post/change-action-mailer-settings-from-rails-console/</link>
      <pubDate>Mon, 07 Oct 2024 21:09:36 -0700</pubDate>
      <guid>https://hsps.in/post/change-action-mailer-settings-from-rails-console/</guid>
      <description>&lt;p&gt;In Rails applications, ActionMailer is a powerful module used to send emails. It’s essential to configure your ActionMailer settings correctly to ensure that your application can send emails reliably through your chosen SMTP server. Typically, these settings are configured in your environment files (e.g., config/environments/production.rb). However, there may be instances where you need to override these settings temporarily through the Rails console—for example, when testing a custom configuration or troubleshooting email delivery issues.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Create JSON Payload for API Test Using Factory Bot</title>
      <link>https://hsps.in/post/create-json-payload-for-api-test-using-factory-bot/</link>
      <pubDate>Sat, 05 Aug 2023 23:06:27 -0700</pubDate>
      <guid>https://hsps.in/post/create-json-payload-for-api-test-using-factory-bot/</guid>
      <description>&lt;p&gt;I am not going to reiterate the PSA (Public Safety Announcement) of how important it is to write test. You can find enough articles related that online, and most probably you already know and agree to it. This article is how to generate JSON payload using Factory Bot.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/thoughtbot/factory_bot&#34;&gt;Factory Bot&lt;/a&gt; is a ruby library that is used to create records in the table for testing. It will help generate data to fill and prepare records, before the test execution.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Rails Copy Assets bundler Cache to Speed Up Build</title>
      <link>https://hsps.in/post/rails-copy-assets-bundler-cache-to-speed-up-build/</link>
      <pubDate>Tue, 01 Aug 2023 17:01:37 -0700</pubDate>
      <guid>https://hsps.in/post/rails-copy-assets-bundler-cache-to-speed-up-build/</guid>
      <description>&lt;p&gt;The slowest step (in my experience and opinion) is compiling assets (js/css). Compiling assets takes time and slower when you do it for the first time. So to speed it up its recommended to copy the last compiled assets from the latest image you have of the repo.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;&#xA;&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4&#xA;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&#xA;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Dockerfile&#34; data-lang=&#34;Dockerfile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;COPY&lt;/span&gt; --from&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;docker-repo.link/image:latest /app/node_modules /app/node_modules&lt;span class=&#34;err&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;COPY&lt;/span&gt; --from&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;docker-repo.link/image:latest /app/public /app/public&lt;span class=&#34;err&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;RUN&lt;/span&gt; bundle &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; rails assets:precompile&lt;span class=&#34;err&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;Now since the prior assets are in the new image, it won&amp;rsquo;t compile the assets from scratch and the build will be faster.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Running Migrations From Console</title>
      <link>https://hsps.in/post/running-migrations-from-console/</link>
      <pubDate>Tue, 19 Jul 2022 23:15:19 -0700</pubDate>
      <guid>https://hsps.in/post/running-migrations-from-console/</guid>
      <description>&lt;p&gt;Note: I am using Apartment gem to manage my multi schema database, and this article is written with expectation you know and use that gem.&lt;/p&gt;&#xA;&lt;p&gt;When you have multiple schema in your rails application, it is important for them to remain consistent. Rails migration is run by keeping track of the timestamp prefixed in front of its file name. It stores the database. So when you restore a schema that hasn&amp;rsquo;t ran the migration, but rest of the schemas has it, rails thinks it has already ran the migration. Rails look at the main / default schema to know if it has ran the migrations  and then follow up on the rest.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Access History in IRB</title>
      <link>https://hsps.in/post/access-history-in-irb/</link>
      <pubDate>Sun, 17 Jul 2022 13:15:49 -0700</pubDate>
      <guid>https://hsps.in/post/access-history-in-irb/</guid>
      <description>&lt;p&gt;Accessing the list of commands you have ran in your &lt;code&gt;irb&lt;/code&gt; or &lt;code&gt;rails console&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Running the following command in your console &lt;code&gt;Readline::HISTORY.to_a&lt;/code&gt; returns the array of commands you have typed in console. After which you can treat it like any other array in ruby - search, sort, etc.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Using String in Active Record(Rails) Enum</title>
      <link>https://hsps.in/post/using-string-as-active-record-enum/</link>
      <pubDate>Tue, 31 May 2022 20:10:36 -0700</pubDate>
      <guid>https://hsps.in/post/using-string-as-active-record-enum/</guid>
      <description>&lt;p&gt;Rails model helps you define enum on a database integer field quite easily. The enum method which rails provide in its model is not an interface to the enum datatype available in some databases, but converting or using a integer field as an enum. Enum type or Enumerated type is user defined data type where you define the set of value the data type will have. If you consider regular or basic or primitive data types, they are pretty much like enum where the values it can hold is defined already by the language. Ruby dynamic type system does hide all this complexity for us while we develop.&lt;/p&gt;&#xA;&lt;p&gt;Enum is quite useful when you want to make sure that only a specified list of values are saved for a field.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Count How Many Routes You Have</title>
      <link>https://hsps.in/post/count-how-many-routes-you-have/</link>
      <pubDate>Tue, 17 May 2022 17:21:51 -0700</pubDate>
      <guid>https://hsps.in/post/count-how-many-routes-you-have/</guid>
      <description>&lt;p&gt;It start with one, then two and it keeps on growing. The number of routes in your ruby on rails project can be a reflection of how complex your project is becoming. And if you are curious like me to know how many routes your project has, just run the following command in your rails console.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Review on Rail 4.3.0 Beta</title>
      <link>https://hsps.in/post/review-on-rail-4.3.0-beta/</link>
      <pubDate>Wed, 20 Aug 2014 00:00:00 -0530</pubDate>
      <guid>https://hsps.in/post/review-on-rail-4.3.0-beta/</guid>
      <description>&lt;p&gt;Active Job, deliver later will give us a lot of abstraction. One will have to move the business logic present in workers to models or services, but that would make our system more maintainable. If the Active Job is a simple plug and play then in future projects one can use delayed_job when the load is light and when the load increases they can shift to redis based resque or sidekiq. Thinking of migrating from one system to another always give the developers a head ache. This can essentially solve it. Active Job was planned to be a feature in rails 4.0 but later they decided not. I am glad that they are releasing it in 4.2&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
