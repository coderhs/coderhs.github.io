<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>rails on Harisankar P S | HsPS.in</title>
    <link>https://hsps.in/tags/rails/</link>
    <description>Recent content in rails on Harisankar P S | HsPS.in</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 19 Jul 2022 23:15:19 -0700</lastBuildDate><atom:link href="https://hsps.in/tags/rails/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Running Migrations From Console</title>
      <link>https://hsps.in/post/running-migrations-from-console/</link>
      <pubDate>Tue, 19 Jul 2022 23:15:19 -0700</pubDate>
      
      <guid>https://hsps.in/post/running-migrations-from-console/</guid>
      <description>&lt;p&gt;Note: I am using Apartment gem to manage my multi schema database, and this article is written with expectation you know and use that gem.&lt;/p&gt;
&lt;p&gt;When you have multiple schema in your rails application, it is important for them to remain consistent. Rails migration is run by keeping track of the timestamp prefixed in front of its file name. It stores the database. So when you restore a schema that hasn&amp;rsquo;t ran the migration, but rest of the schemas has it, rails thinks it has already ran the migration. Rails look at the main / default schema to know if it has ran the migrations  and then follow up on the rest.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Access History in IRB</title>
      <link>https://hsps.in/post/access-history-in-irb/</link>
      <pubDate>Sun, 17 Jul 2022 13:15:49 -0700</pubDate>
      
      <guid>https://hsps.in/post/access-history-in-irb/</guid>
      <description>Accessing the list of commands you have ran in your irb or rails console.
Running the following command in your console Readline::HISTORY.to_a returns the array of commands you have typed in console. After which you can treat it like any other array in ruby - search, sort, etc.</description>
    </item>
    
    <item>
      <title>Using String in Active Record(Rails) Enum</title>
      <link>https://hsps.in/post/using-string-as-active-record-enum/</link>
      <pubDate>Tue, 31 May 2022 20:10:36 -0700</pubDate>
      
      <guid>https://hsps.in/post/using-string-as-active-record-enum/</guid>
      <description>&lt;p&gt;Rails model helps you define enum on a database integer field quite easily. The enum method which rails provide in its model is not an interface to the enum datatype available in some databases, but converting or using a integer field as an enum. Enum type or Enumerated type is user defined data type where you define the set of value the data type will have. If you consider regular or basic or primitive data types, they are pretty much like enum where the values it can hold is defined already by the language. Ruby dynamic type system does hide all this complexity for us while we develop.&lt;/p&gt;
&lt;p&gt;Enum is quite useful when you want to make sure that only a specified list of values are saved for a field.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Count How Many Routes You Have</title>
      <link>https://hsps.in/post/count-how-many-routes-you-have/</link>
      <pubDate>Tue, 17 May 2022 17:21:51 -0700</pubDate>
      
      <guid>https://hsps.in/post/count-how-many-routes-you-have/</guid>
      <description>&lt;p&gt;It start with one, then two and it keeps on growing. The number of routes in your ruby on rails project can be a reflection of how complex your project is becoming. And if you are curious like me to know how many routes your project has, just run the following command in your rails console.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Review on Rail 4.3.0 Beta</title>
      <link>https://hsps.in/post/review-on-rail-4.3.0-beta/</link>
      <pubDate>Wed, 20 Aug 2014 00:00:00 -0530</pubDate>
      
      <guid>https://hsps.in/post/review-on-rail-4.3.0-beta/</guid>
      <description>&lt;p&gt;Active Job, deliver later will give us a lot of abstraction. One will have to move the business logic present in workers to models or services, but that would make our system more maintainable. If the Active Job is a simple plug and play then in future projects one can use delayed_job when the load is light and when the load increases they can shift to redis based resque or sidekiq. Thinking of migrating from one system to another always give the developers a head ache. This can essentially solve it. Active Job was planned to be a feature in rails 4.0 but later they decided not. I am glad that they are releasing it in 4.2&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
