<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Productivity on Harisankar P S | Ruby on Rails Developer</title>
    <link>https://hsps.in/categories/productivity/</link>
    <description>Recent content in Productivity on Harisankar P S | Ruby on Rails Developer</description>
    <generator>Hugo</generator>
    <language>en</language>
    <copyright>Harisankar P S</copyright>
    <lastBuildDate>Sun, 07 Dec 2025 19:15:00 +0530</lastBuildDate>
    <atom:link href="https://hsps.in/categories/productivity/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Git Worktree: Scaling Your AI Workflow</title>
      <link>https://hsps.in/post/git-worktree-ai-workflow/</link>
      <pubDate>Sun, 07 Dec 2025 19:15:00 +0530</pubDate>
      <guid>https://hsps.in/post/git-worktree-ai-workflow/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve been using &lt;code&gt;git&lt;/code&gt; for years, but to be honest, I wasn&amp;rsquo;t even aware of &lt;code&gt;git worktree&lt;/code&gt; until I started using AI for development.&lt;/p&gt;&#xA;&lt;p&gt;Before this, my workflow for context switching was pretty standard. If I was in the middle of something and needed to check another branch or fix a bug, I&amp;rsquo;d rely on &lt;code&gt;git stash&lt;/code&gt; or &lt;code&gt;git stash -u&lt;/code&gt; (to catch those untracked files). Sometimes I&amp;rsquo;d just commit what I had, knowing I would eventually &amp;ldquo;Squash and Merge&amp;rdquo; my Pull Requests anyway, so a few messy &amp;ldquo;WIP&amp;rdquo; commits didn&amp;rsquo;t really matter.&lt;/p&gt;&#xA;&lt;p&gt;But recently, I found a new bottleneck: &lt;strong&gt;I have more ideas than I have open AI contexts.&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;We often treat AI as a faster pair programmer, but we still tend to work sequentially. We ask Cursor or Claude Code to do X, watch it generate code, review it, and then move to Y.&lt;/p&gt;&#xA;&lt;p&gt;But what if you could implement Idea A, Idea B, and Fix C all at the same time?&lt;/p&gt;&#xA;&lt;p&gt;Enter &lt;code&gt;git worktree&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Tailscale for Single User Single Host</title>
      <link>https://hsps.in/post/tailscale-for-single-user-single-host/</link>
      <pubDate>Wed, 08 Jan 2025 18:55:49 +0530</pubDate>
      <guid>https://hsps.in/post/tailscale-for-single-user-single-host/</guid>
      <description>&lt;p&gt;I often see articles discussing Tailscale in multi-device setups, but I wanted to share my experience of using Tailscale primarily with a single machine. To clarify, it&amp;rsquo;s not technically a single device, but a combination of my work computer, phone, and a 10-inch Android tablet.&lt;/p&gt;&#xA;&lt;h2 id=&#34;the-problem-inefficient-remote-access&#34;&gt;The Problem: Inefficient Remote Access&lt;/h2&gt;&#xA;&lt;p&gt;I work from home, and my computer serves as both my personal and work machine. There have been many times when Iâ€™ve needed to assist colleagues or push changes while away from my desk. In emergencies, I used to rely on AnyDesk to remote into my computer via my phone or tablet. While AnyDesk and similar tools like TeamViewer provide visual control over the desktop, they often suffer from lag, disconnections, and poor responsiveness on weaker connections, making simple tasks like opening a terminal or editing a file feel like a chore. The lag becomes especially pronounced when navigating large projects or deploying code, turning a few-minute task into a frustrating, time-consuming ordeal.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
